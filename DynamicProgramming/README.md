## [플래4]경찰차(http://www.acmicpc.net/problem/2618)

- 문제: (1, 1)에 위치한 경찰차1과 (N, N)에 위치한 경찰차2가 순서대로 사건을 처리하면서 두 경찰차가 이동한 최소거리를 구하여라

* 알고리즘: `DP`

* 해설

  - **점화식(dp테이블을 정의하기 상당히 어려움)**

    `dp[i][j]` = 경찰차1이 마지막으로 처리한 사건번호 i이고 경찰차2가 마지막으로 처리한 사건번호가 j일때 이동한 최소거리

  - **dp를 사용할 수 있는 이유**

    예를 들어 경찰차1이 6번을 마지막으로 처리하고 경찰차2가 4번을 마지막으로 처리했다라고 하면 '???211'로 앞 3사건의 배열에 대한 경우의 수를 고려할 필요 없이 고정할 수 있다.

  - **풀이**

    바텀업방식을 통해서 풀이를 진행하였다. 사건개수만큼 for문을 반복하는데 예를 들어 i = 6이라고 하면, dp[6][0] ~ dp[6][5], dp[0][6] ~ dp[5][6] 에 해당하는 모든 경우를 구해야 한다.

    dp[6][0], dp[6][1], dp[6][2] 등 두사건의 차이가 1보다 클때는 작은 사건번호의 최댓값이 고정이다. 왜냐하면 이를 수정할 경우 마지막으로 처리한 사건번호가 변경되기 때문이다. 그래서 단순히 `dp[6][2] = dp[5][2] + 경찰차1이 5에서 6까지의 거리` 로 값을 구할 수 있다.

    하지만 dp[6][5]같은 경우는 dp[5][5]가 정의되지 않기 때문에 `dp[0 ~ 4][5] + dist`중 최솟값으로 정의된다.

  - 입력

    ```
    6
    3
    3 5
    5 5
    2 3
    ```

  - 출력

    ```
    9
    2
    2
    1
    ```

<br>

## [골드3]파일 합치기(http://www.acmicpc.net/problem/11066)

- 문제: 파일 크기가 배열로 주어지고, 파일을 합치는 비용은 파일 크기의 합이다. 이 파일들을 하나의 파일로 합칠 때 최소비용을 구하여라. 단, 연속된 파일만 합칠 수 있다.

* 알고리즘: `DP`

* 해설: `dp[i][j]`는 i부터 j까지의 최소비용으로 `dp[i][j] = min([(dp[i][k] + dp[k + 1][j])
for k in range(i, j)]) + (psum[j] - psum[i - 1])` 의 점화식을 가진다.
  결국 파일을 합칠 때는 2개의 파일(합쳐진 파일 or 하나의 파일)을 합치는 경우이다.

  - 입력

    ```
    4
    40 30 30 50
    15
    1 21 3 4 5 35 5 4 3 5 98 21 14 17 32
    ```

  - 출력

    ```
    300
    864
    ```

<br>

## [골드3]내리막 길(http://www.acmicpc.net/problem/1520)

- 문제: 각 칸의 지점의 높이가 쓰여진 지도가 주어지고 항상 높이가 낮은 지점으로만 이동하여 목표지점까지 도달하고자 한다.

* 알고리즘: `DP`, `DFS`

* 해설: m, n의 크기가 500이하일 때, 방문처리를 안할 경우 그래프 탐색의 시간복잡도는 O(이동경로의 수 ^ (NM))이다. 예를 들어, m, n이 각각 2, 1일 경우 그래프의 크기가 2이므로 (상하좌우) x (상하좌우) = 4^2 의 경우의 수가 발생한다. 그러므로 O(4 ^ 500 x 500)의 시간복잡도를 가지므로 dp를 사용해서 이전에 이미 계산된 경로의 경우 반복된 계산을 하지 않도록 한다.

  - **목표지점에 도달했을 때 지나온 경로에 dp를 기록하는 것이 핵심이다.**
  - 입력

    ```
    4 5
    50 45 37 32 30
    35 50 40 20 25
    30 30 25 17 28
    27 24 22 15 10
    ```

  - 출력

    ```
    3
    ```

<br>

## [골드3]양팔저울(http://www.acmicpc.net/problem/2629)

- 문제: 추의 무게들이 오름차순으로 주어질 때, 양팔저울을 사용해서 미지의 구슬의 무게를 알 수 있는지 판단해라.

* 알고리즘: `DP`, `냅색 알고리즘`

* 해설: 주어진 추 무게 배열을 냅색 알고리즘을 통해서 이전에 계산한 무게들과 현재 추의 무게의 관계를 통해 구할 수 있는 무게를 최신화한다.

  - 경우의 수
    - 현재 추의 무게 - 이전 배열의 무게
    - 현재 추의 무게 + 이전 배열의 무게
    - **이전 배열의 무게 - 현재 추의 무게** -> 놓치기 쉬움
  - 입력

    ```
    2
    1 4
    2
    3 2
    ```

  - 출력

    ```
    Y N
    ```

<br>

## [골드3]앱(http://www.acmicpc.net/problem/7579)

- 문제: 필요한 메모리 M 바이트를 확보하기 위한 앱 비활성화의 최소의 비용을 계산

* 알고리즘: `DP`, `냅색 알고리즘`

* 해설:

  - 1 ≤ N ≤ 100, 1 ≤ M ≤ 10,000,000이며, 1 ≤ m1, ..., mN ≤ 10,000,000을 만족한다. 또한, 0 ≤ c1, ..., cN ≤ 100이고, M ≤ m1 + m2 + ... + mN을 만족한다.
  - **발상의 전환: M을 기준으로 냅색을 수행하면 배열의 크기가 너무 커진다. 그래서 인덱스를 비용으로 놓고 냅색을 수행**한다. 비용이 idx일때, 확보할 수 있는 최대 바이트를 `dp[i][j]`로 정의하고 냅색을 진행하면 된다.
  - 입력

    ```
    5 60
    30 10 20 35 40
    3 0 3 5 4
    ```

  - 출력

    ```
    6
    ```

<br>

## [골드4]RGB거리 2(http://www.acmicpc.net/problem/17404)

- 문제: 각각의 집을 빨강, 초록, 파랑으로 칠하는 비용이 주어졌을 때, 아래 규칙을 만족하면서 모든 집을 칠하는 비용의 최솟값을 구해보자.

  - 연속된 색상으로 집을 칠할 수 없다.
  - 1번 집과 N번 집의 색상은 같으면 안 된다.

* 알고리즘: `DP`

* 해설:

  - 탑다운

    ```python
    dp = [[[-1] * 3 for i in range(3)] for j in range(n)]

    def dfs(row, col, start):
        # dp[row][col][start]: row, col을 포함하며, 시작점이 start일때, 남은 경로를 완성하는 최소비용
        if row == n - 1:
            if col == start:
                dp[row][col][start] = float('inf')
            else:
                dp[row][col][start] = cost[row][col]
            return dp[row][col][start]

        if dp[row][col][start] != -1:
            return dp[row][col][start]

        temp = float('inf')
        for i in range(3):
            if col == i:
                continue
            temp = min(temp, cost[row][col] + dfs(row + 1, i, start))
        dp[row][col][start] = temp
        return dp[row][col][start]

    result = [dfs(0, 0, 0), dfs(0, 1, 1), dfs(0, 2, 2)]
    ```

    - dp테이블을 역순으로 **남은 경로를 최소비용으로 완성할 때의 비용**으로 가정하고 작성

      ```
      [[172, -1, -1], [-1, 110, -1], [-1, -1, 156]]
      [[-1, 148, 138], [159, -1, 73], [146, 70, -1]]
      [[inf, 13, 13], [89, inf, 89], [99, 99, inf]]
      ```

  - 바텀업

    ```python
    for i in range(3):
    dp[1] = [float('inf'), float('inf'), float('inf')]
    dp[1][i] = cost[0][i]

    for j in range(2, n + 1):
        dp[j][R] = cost[j - 1][R] + min(dp[j - 1][G], dp[j - 1][B])
        dp[j][G] = cost[j - 1][G] + min(dp[j - 1][R], dp[j - 1][B])
        dp[j][B] = cost[j - 1][B] + min(dp[j - 1][R], dp[j - 1][G])

    dp[n][i] = float('inf')
    result = min(result, min(dp[n]))
    ```

    - 참고: RGB거리<<http://www.acmicpc.net/problem/1149>>

    - 시작 집이 R인 경우와 G, B인 경우를 다 각각 바텀업으로 구한 뒤 가장 작은 결과값을 출력한다.

  - 입력

    ```
    3
    26 40 83
    49 60 57
    13 89 99
    ```

  - 출력

    ```
    110
    ```

<br>

## [골드4]가장 큰 정사각형(http://www.acmicpc.net/problem/1915)

- 문제: 배열에서 1로 된 가장 큰 정사각형의 크기를 구하시오. `n, m(1 <= n, m <= 1,000)`

* 알고리즘: `DP`

* 해설:

  - dp 배열: 해당 좌표를 정사각형의 오른쪽 아래의 점이라고 생각했을 때 위,왼쪽에 대한 연속된 1의 개수

    ```python
    dp = [[[0, 0] for i in range(m+1)] for j in range(n+1)]
    for i in range(n):
        for j in range(m):
            if graph[i][j] == 1:
                dp[i+1][j+1][1] = dp[i][j+1][1] + 1
                dp[i+1][j+1][0] = dp[i+1][j][0] + 1
    ```

    ```
    6 6
    111011
    111111
    111111
    001111
    111111
    111111

    [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0]]
    [[0, 0], [1, 1], [2, 1], [3, 1], [0, 0], [1, 1], [2, 1]]
    [[0, 0], [1, 2], [2, 2], [3, 2], [4, 1], [5, 2], [6, 2]]
    [[0, 0], [1, 3], [2, 3], [3, 3], [4, 2], [5, 3], [6, 3]]
    [[0, 0], [0, 0], [0, 0], [1, 4], [2, 3], [3, 4], [4, 4]]
    [[0, 0], [1, 1], [2, 1], [3, 5], [4, 4], [5, 5], [6, 5]]
    [[0, 0], [1, 2], [2, 2], [3, 6], [4, 5], [5, 6], [6, 6]]
    ```

    해당 배열을 처음부터 순회하면서 만약 최대 정사각형의 크기를 구한다. 만약 `(i, j)` 좌표에서 위, 왼쪽의 길이가 `(i-1, j-1)`좌표의 최대 정사각형의 길이를 포함한다면 `+1`해준다.

  - 입력

    ```
    4 4
    0100
    0111
    1110
    0010
    ```

  - 출력

    ```
    4
    ```

<br>
