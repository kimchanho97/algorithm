## [골드2]가장 긴 증가하는 부분 수열 2(http://www.acmicpc.net/problem/12015)

- 문제: 가장 긴 증가하는 부분 수열
  - 조건: 수열의 길이 (1 <= N <= 1,000,000)
  - 함정: 단순히 `dp` 로 해결하면 시간 O(n^2)으로 시간 초과 발생

* 알고리즘: `이분 탐색`

* 해설: 한번의 순회로 정답을 찾아야 한다. 빈 배열을 만들고 주어진 배열을 순회하면서 만약 배열의 마지막 원소보다 클 경우 추가하고 아닐 경우, 이분 탐색으로 위치를 찾는다.
  특정 위치의 원소를 해당 원소로 변경한다. `bisect_left` 를 사용해서 증가하는 속성은 유지한 채 원소를 더 작은 값으로 업데이트함으로써 후속 원소들이 더 추가될 수 있는 가능성을 높인다. 이는 실제 LIS와는 다르지만 길이는 같다.

  - 입력

  ```
  6
  10 20 10 30 20 50
  ```

  - 출력

  ```
  4
  ```

<br>

## [실버2]가장 긴 증가하는 부분 수열 2(http://www.acmicpc.net/problem/11053)

- 문제: 가장 긴 증가하는 부분 수열
  - 조건: 수열의 길이 (1 <= N <= 1,000)

* 알고리즘: `DP`

* 해설: DP를 활용한 방법으로 `dp[i] = i까지 가장 긴 증가하는 부분 수열의 길이` 로 정의하고 이중 배열을 순회하면서 만약 현재 원소가 더 클 경우 (dp[i] + 1)을 해줌으로써 가장 긴 증가하는 부분 수열의 길이를 구한다.

  - 입력

  ```
  6
  10 20 10 30 20 50
  ```

  - 출력

  ```
  4
  ```

<br>

## [플래5]가장 긴 증가하는 부분 수열 2(http://www.acmicpc.net/problem/14003)

- 문제: 이분탐색을 사용해서 가장 긴 증가하는 부분 수열을 구하는 길이를 구하되, 실제 LIS를 출력해야 한다.
  - 조건: 수열의 길이 (1 <= N <= 1,000,000)

* 알고리즘: `이분 탐색`

* 해설: 이분탐색으로 배열을 수정하는 방식은 가능성을 높이기 위해 길이만 같을 뿐 실제 LIS와는 다를 수 있다. 실제 LIS를 출력하기 위해서 해당 원소 이전의 가장 큰 원소의 index를 저장하는 새로운 배열을 만들어서 관리한다. 더 작은 원소로 갱신될 때 처음 원소가 아니면 이전의 원소는 크기가 작은게 확실하다. 그래서 해당 index를 저장해준다.

  ```python
  lst = []  # 실제 값이 저장될 리스트
  indexes = []  # lst 배열의 각 원소가 arr에서 어떤 인덱스에 해당하는지 저장
  p = [-1] * len(arr)  # 각 원소가 LIS에 추가될 때의 '이전 원소 인덱스'를 저장
  ```

  ```python
  # i보다 작은 인덱스 중 가장 큰 인덱스를 찾아서 p[i]에 저장
    if idx > 0: # idx가 0이면 이전 원소가 없으므로 p[i] = -1
      p[i] = indexes[idx -1]
  ```

  - 입력

  ```
  6
  10 20 10 30 20 50
  ```

  - 출력

  ```
  4
  10 20 30 50
  ```

<br>
