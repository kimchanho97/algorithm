## [골드1]외판원 순회(http://www.acmicpc.net/problem/2098)

- 문제: 어느 한 도시에서 출발해 N개의 도시를 모두 거쳐 다시 원래의 도시로 돌아오는 순회 여행 경로를 계획하려고 한다. 가장 적은 비용을 들이는 외판원의 순회 여행 경로를 구하는 프로그램을 작성하시오.

* 알고리즘: `비트마스킹`, `DP`

* 해설

  - 비트마스킹
    배열의 상태를 저장해야하는 경우, 값 하나에 비트 단위로 여러 개의 상태를 표시하는 기법(n이 작을 경우)

  - `tsp(cur_town, visited)`
    현재 currentTown에 있고 visited에 속한 마을들을 이미 방문하였을 때, 방문하지 않은 마을들을 순회하여 시작점으로 돌아가는 최단거리 -> `dp[cur_town][visited]`

  - 입력

    ```
    4
    0 10 15 20
    5 0 9 10
    6 13 0 12
    8 8 9 0
    ```

  - 출력

    ```
    35
    ```

<br>

## [골드1]계단수(http://www.acmicpc.net/problem/1562)

- 문제: 길이가 N이면서 0부터 9까지 숫자가 모두 등장하는 계단 수가 총 몇 개 있는지 구하는 프로그램을 작성하시오.

* 알고리즘: `비트마스킹`, `DP`

* 해설

  - 쉬운 계단 수
    state가 없는 계단 수를 구하는 문제: <https://www.acmicpc.net/problem/10844>

  - 위 문제와 동일하게 바텀업 방식으로 계단수를 누적해가는데 각 숫자의 사용여부를 나타내는 수가 상태로 추가되었다.

    `dp[n][10][(1 << 10)]` : n(숫자의 길이), 10(마지막 숫자), 1 << 10(state)

  - 입력

    ```
    10
    ```

  - 출력

    ```
    1
    ```

<br>
