## [골드1]외판원 순회(http://www.acmicpc.net/problem/2098)

- 문제: 어느 한 도시에서 출발해 N개의 도시를 모두 거쳐 다시 원래의 도시로 돌아오는 순회 여행 경로를 계획하려고 한다. 가장 적은 비용을 들이는 외판원의 순회 여행 경로를 구하는 프로그램을 작성하시오.

* 알고리즘: `비트마스킹`, `DP`

* 해설

  - 비트마스킹

    배열의 상태를 저장해야하는 경우, 값 하나에 비트 단위로 여러 개의 상태를 표시하는 기법(n이 작을 경우)

  - `tsp(cur_town, visited)`

    현재 currentTown에 있고 visited에 속한 마을들을 이미 방문하였을 때, 방문하지 않은 마을들을 순회하여 시작점으로 돌아가는 최단거리 -> `dp[cur_town][visited]`

  - 입력

    ```
    4
    0 10 15 20
    5 0 9 10
    6 13 0 12
    8 8 9 0
    ```

  - 출력

    ```
    35
    ```

<br>

## [골드1]계단수(http://www.acmicpc.net/problem/1562)

- 문제: 길이가 N이면서 0부터 9까지 숫자가 모두 등장하는 계단 수가 총 몇 개 있는지 구하는 프로그램을 작성하시오.

* 알고리즘: `비트마스킹`, `DP`

* 해설

  - 쉬운 계단 수

    state가 없는 계단 수를 구하는 문제: <https://www.acmicpc.net/problem/10844>

  - 위 문제와 동일하게 바텀업 방식으로 계단수를 누적해가는데 각 숫자의 사용여부를 나타내는 수가 상태로 추가되었다.

    `dp[n][10][(1 << 10)]` : n(숫자의 길이), 10(마지막 숫자), 1 << 10(state)

  - 입력

    ```
    10
    ```

  - 출력

    ```
    1
    ```

<br>

## [골드4]가르침(http://www.acmicpc.net/problem/1062)

- 문제: 본인은 영어 알파벳 중 단 `k`개만 읽을 수 있다. 여러 단어들이 주어질 때, 읽을 수 있는 최대 개수를 구하여라.

* 알고리즘: `비트마스킹`, `완전탐색`

* 해설

  - `k`개의 알파벳 조합 내에서 만들어진 단어는 읽을 수 있는 단어이다.

    - 예를 들어, 4개의 알파벳 조합 `(a, b, c, d)`와 단어 `abc`를 비교해보자. 단어의 길이를 m이라고 한다면, 알파벳 조합이 set일 경우 `O(m)`, set이 아닌 경우, `O(n x m)`이다.

  - 영어 알파벳 조합을 비트마스킹을 통해 나타낼 수 있다.

    ```python
    def wordToBit(word):
    bit = 0
    for i in word:
        bit = bit | (1 << (ord(i) - ord('a')))
    return bit
    ```

    - 총 26자리수로 32를 넘지 않기에 영어 조합을 int로 변환할 수 있다.

  - 비트마스킹을 사용하면 한 알파벳 조합이 다른 알파벳 조합에 포함되는지 `O(1)`의 시간으로 알 수 있다.

    - 기존의 `k`개의 조합 내에서 생성된 단어는 무조건 읽을 수 있다. 만약 포함관계라고 한다면 `k`개의 조합이 다른 조합을 포함한다.

    ```
    예시: 알파벳 3개의 조합 ace와 단어 'ac'와 'ad'
    ace = 10101
    ac = 10100
    ad = 10010

     ac -> 1 0 1 0 0
    ace -> 1 0 1 0 1
    -----------------
     ac -> 1 0 1 0 0

     ad -> 1 0 0 1 0
    ace -> 1 0 1 0 1
    -----------------
      a -> 1 0 0 0 0

    ```

    ```python
    count = 0
    for word in words:
        if word & comb == word:
            count += 1
    ```

    - `&` 연산을 수행해서 자기 자신이 나오면 포함되는 것이다.

<br>
