## [골드3]말이 되고픈 원숭이(http://www.acmicpc.net/problem/1900)

- 문제: 체스(말) 이동이 추가된 그래프 탐색

* 알고리즘: `BFS`, `그래프 탐색`

* 해설

  이동을 `체스`와 `그냥`으로 나누었을때, 체스가 어느 순서에 들어가냐에 따라 다양한 경로가 나온다. 따라서 이 문제의 핵심은 **방문처리**이다.

  - 체스 횟수마다 방문처리 배열 생성(첫번째 시도)

    ```python
    visit = [[[False] * m for i in range(n)] for j in range(k+1)]
    ```

    visit 배열을 체스 횟수만큼 생성해서 방문처리를 시도 -> 메모리 초과

  - `cnt` 횟수에 따른 방문처리(두번째 시도)

    이 문제는 **중복 방문**을 허용해줘야 한다. 그래서 `cnt`를 `visit`에 저장하고 더 작을 경우 방문을 허용했다. 하지만 이런 경우 다익스트라와 동일하게 작동하며 `체스`이동을 미리 한 경로값이 더 작기에 `그냥`이동을 한 경로는 무시된다. 하지만 초반에는 `그냥`이동을 하다가 나중에 `체스`이동을 몰아서 해야 하는 반례가 존재하게 된다.

    ```
    2
    10 2
    0 0 1 0 0 1 0 0 1 0
    0 0 1 1 0 0 0 0 1 0
    ```

  - 남은 점프 횟수에 따른 방문처리

    **중복 방문을 허용할려면 방문처리를 불린값이 아닌 정수값에 의해 결정**해야 한다. `cnt`값이 아닌 남은 점프 횟수값으로 만약 점프 횟수가 더 많이 남은 경로일 경우 방문을 허용해주면 된다.

    ```python
    for dr, dc in horse:
        nr, nc = curR + dr, curC + dc
        if 0 <= nr < n and 0 <= nc < m and graph[nr][nc] == 0 and jump-1 > visit[nr][nc]:
            q.append((cnt+1, jump-1, nr, nc))
            visit[nr][nc] = jump-1
    ```

<br>

## [실버1]효율적인 해킹(http://www.acmicpc.net/problem/1325)

- 문제: 그래프가 주어졌을 때, 각각의 노드의 직접 및 간접적으로 연결된 노드의 수를 구하여라

* 알고리즘: `BFS`, `그래프 탐색`

* 해설

  - Degree(정도)

    한 노드에 연결된 엣지(간선)의 수

  - **직접 및 간접적으로 연결된 노드의 수**

    특정 노드에서 시작하여 도달할 수 있는 모든 노드의 수

  - 설명

    위 문제는 사이클이 존재할 수도 있는 그래프에서 직접 및 간접적으로 연결된 노드의 수를 구하는 문제이다.

    - 사이클이 없는 트리: **한 번의 DFS 또는 BFS**를 통해 모든 노드의 자식 노드 수를 계산할 수 있다.
    - 사이클이 있는 그래프: **각 노드를 시작점으로 하는 DFS 또는 BFS를 별도로 수행**해야 한다.(사이클이 존재하면 직접 및 간접적으로 연결된 노드의 수는 전체 노드 수와 같을 수도 있기에 한 번의 탐색으로 모든 연결 요소 크기를 결정하는 것이 불가능하다.)

  - 입력

    ```
    5 4
    3 1
    3 2
    4 3
    5 3
    ```

  - 출력

    ```
    1 2
    ```

<br>
