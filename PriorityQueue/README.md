## [골드2]보석 도둑(http://www.acmicpc.net/problem/1202)

- 문제: 각 가방 안에 한 개의 보석만 넣을 수 있을 때, 훔칠 수 있는 최대 보석의 가격은?

* 알고리즘: `우선순위 큐`, `정렬`

* 해설

  - 방법1: 가격순으로 정렬한 뒤, 이 보석을 현재 넣을 수 있는 곳 중 가방 용량이 가장 작은 곳에 넣어야 한다.

    ```
    무게  1  2  5  1  5
    가격 101 99 90 65 23

    가방 2 4 10
    ```

    - (1, 101): 가방 무게가 1보다 큰 가방 `(2, 4, 10)` 중 가방`(2)`에 넣음
    - (2, 99): 가방 무게가 2보다 큰 가방 `(4, 10)` 중 가방`(4)`에 넣음
    - (5, 90): 가방 무게가 5보다 큰 가방 `(10)` 중 가방`(10)`에 넣음
    - (1, 65): 가방 무게가 1보다 큰 가방 `(2, 4, 10)` 중 넣을 수 있는 곳 없음(X)
    - (5, 23): 가방 무게가 5보다 큰 가방 `(10)` 중 넣을 수 있는 곳 없음(X)

    `(2, 99)` case처럼 가방 무게가 2보다 큰 가방 중 넣을 수 있는 곳을 찾는 것은 여전히 순차적으로 찾게된다.(`O(n)`)

    -> 인덱스 접근을 하기 위해 **세그먼트 트리** 사용: 최솟값 세그먼트 트리를 사용해서 가능한 가방 중 보석의 가격이 가장 작은 위치를 반환하도록 한다. 여전히 가격순으로 정렬을 꼭 해야된다. 정렬을 함으로써 가장 작은 가방에 가장 비싼 보석이 들어간다.(반례: 위 예시 - 정렬을 하지 않을 경우 최적의 해를 보장하지 못함)

  - 방법2: 방법1처럼 보석이 가방을 결정하는 것(`보석 -> 가방`)이 아닌 가방이 보석을 결정(`가방 -> 보석`)하도록 구현

    ```
    무게  1  1  2  5  5
    가격 65 101 99 23 90

    가방 2 4 10
    ```

    무게가 작은 가방부터 들어갈 수 있는 보석 중 가장 가격이 비싼 보석을 선택한다. 오름차순으로 정렬하는 이유는 작은 가방에 작은 보석을 우선적으로 넣어서 나중에 큰 무게의 보석 담는 것을 보장한다.

    - 2: (1, 65), (1, 101), (2, 99) 중 (1, 101) 선택
    - 4: (1, 65), (2, 99) 중 (2, 99) 선택
    - 10: (1, 65), (5, 23), (5, 90) 중 (5, 90) 선택

<br>

## [골드4]파일 합치기3(http://www.acmicpc.net/problem/13975)

- 문제: 파일 크기가 배열로 주어지고, 파일을 합치는 비용은 파일 크기의 합이다. 이 파일들을 하나의 파일로 합칠 때 최소비용을 구하여라.

* 알고리즘: `우선순위 큐`, `그리디`

* 해설: 파일이 합쳐질 때 기존의 파일크기만큼 비용이 더해진다. 그러므로 파일 크기가 클수록 나중에 파일을 합치고 먼저 합치는 파일의 크기는 작아야 한다.

  - 입력

    ```
    4
    40 30 30 50
    15
    1 21 3 4 5 35 5 4 3 5 98 21 14 17 32
    ```

  - 출력

    ```
    300
    826
    ```
