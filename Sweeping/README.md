## [골드5]선 긋기(http://www.acmicpc.net/problem/2170)

- 문제: 그려진 선(들)의 총 길이를 구하는 프로그램을 작성하시오. 선이 여러 번 그려진 곳은 한 번씩만 계산한다.

* 알고리즘: `스위핑 알고리즘`

* 해설

  - 스위핑 알고리즘

    각 좌표의 위치 x (-1,000,000,000 ≤ x ≤ 1,000,000,000) 범위가 이십억이다. 각각의 좌표를 순회하는 것이 아닌 입력에 따라서 작업을 수행한다. 스위핑이라는 건 그냥 어떤 선이나 공간을 한쪽에서부터 싹 쓸어버린다는 건데 그렇게 하기 위해서는 정렬을 한 뒤 마주치는 요소들의 따라 조치를 한다.

  - 구간 정의

    ```python
    curL, curR = lines[0][0], lines[0][1]
    ```

  - 구간 길이 계산

    ```python
    result = 0
    for line in lines:
        left, right = line
        if left <= curR:
            curR = max(curR, right)
        else:
            result += (curR - curL)
            curL, curR = left, right
    result += (curR - curL)
    ```

  - 입력

    ```
    4
    1 3
    2 5
    3 5
    6 7
    ```

  - 출력

    ```
    5
    ```

<br>

## [골드3]수상 택시(http://www.acmicpc.net/problem/2836)

- 문제: 상근이는 0번 집에 살고 있고, 보트를 이용해서 사람들을 운송하는 일을 하고 있다. M번 집에 가는 길에 사람을 태워주려고 하는데, 다 내려준 후 M번 집으로 이동하는 최솟값을 구하여라.

* 알고리즘: `스위핑 알고리즘`

* 해설

  ![B5894987-E32D-493A-BB56-4ABD00F3FE68_1_201_a](https://github.com/kimchanho97/algorithm/assets/104095041/13c2ac72-1458-48fc-8f6f-81375f9374da)

  정방향으로의 이동은 0 -> M으로 이동하기에 길이값에 영향을 주지 않는다. 결국 역순의 이동만 선별한 뒤 정렬해서 라인스위핑 알고리즘을 통해 역방향의 이동 거리의 총합을 구한다.

  - 입력

    ```
    8 15
    1 12
    3 1
    3 9
    4 2
    7 13
    12 11
    14 11
    14 13
    ```

  - 출력

    ```
    27
    ```

<br>

## [플래3]북서풍(http://www.acmicpc.net/problem/5419)

- 문제: 각각의 좌표가 주어질 때, 북서풍을 이을 수 있는 섬의 쌍의 개수를 출력하라.

* 알고리즘: `스위핑 알고리즘`, `펜윅 트리`

* 해설

  ```
  -11 10
  -11 -10
  -10 10
  -10 -10
  10 10
  10 -10
  ```

  북서풍을 잇기 위해서 위와 같이 x좌표가 작고 y좌표가 큰 순으로 정렬을 한다. for문을 순회하면서 해당 좌표는 이전의 좌표들보다 x좌표는 무조건 크기에 해당 좌표의 y좌표보다 큰 좌표들의 개수만 더해주면 정답이 된다.

  -> 특정 y값보다 작은 점들의 개수를 구하는 방법: 펜윅트리

  - 좌표 압축

    ```python
    dots = []
    temp = []
    idx = dict()
    for _ in range(n):
        a, b = map(int, sys.stdin.readline().split())
        dots.append([a, b])
        temp.append(b)

    # y좌표가 작을수록 더 큰 순서를 받는 것
    temp.sort(reverse=True)
    for i, val in enumerate(temp):
        if val in idx:
            continue
        idx[val] = len(idx) + 1

    dots.sort(key=lambda x: (x[0], -x[1]))
    # print(dots) : [[-11, 10], [-11, -10], [-10, 10], [-10, -10], [10, 10], [10, -10]]
    for dot in dots:
        dot[1] = idx[dot[1]]
    # print(dots) : [[-11, 1], [-11, 2], [-10, 1], [-10, 2], [10, 1], [10, 2]]
    ```

    y좌표의 범위가 크기에 좌표 압축을 수행한다. 정렬은 한 뒤, y값이 작을수록 더 큰 좌표값을 부여한다. y값이 작을수록 이을 수 있는 섬의 개수가 증가하기 때문이다.

  - 입력

    ```
    2
    4
    -10 -10
    -10 10
    10 -10
    10 10
    3
    1 3
    2 2
    3 1
    ```

  - 출력

    ```
    5
    3
    ```

<br>
